	
	edges_ 		= INTEGER(VECTOR_ELT(mesh_, 6)); 
	VECTOR_ELT estrae l'elemento 7 dalla lista e lo mette come puntatore, in questo caso come puntatore a intero 


num_nodes_ = INTEGER(Rf_getAttrib(VECTOR_ELT(mesh_, 0), R_DimSymbol))[0]; //get length->il [0] serve perchè è un punatore e voglio invece l'elemento semplice

		


UInt num_int_nodes = Rf_length(RGlobalVector)/4;

neumann nulle al bordo

std::for_each(bc_indices_.begin(), bc_indices_.end(), [](int& i){i-=1;}); //R parte da 1, passo la lambda function per tornare a numerazione c++ da 0 

REAL, INTEGER, ecc restituiscono array!!!!! del tipo che è indicato in maiuscolo

n_ = INTEGER(Rf_getAttrib(Rcovariates, R_DimSymbol))[0]; //_se è un vettore uso Rf_length, essendo una matrice, uso questa formulazione per avere le due lunghezze, righe, colonne


???cosa è il bool _DOFS??? fa calcolarei deg of freedon se è true


IN R usa edf in cui c'è il valore dei degrees of freedom


\frac{dL}{d\theta} = \sum_i \frac{dA_{ii}}{d\theta} = \text{Tr} (\frac{dA_{ij}}{dtheta})


possibile futuro formaggesco: factories per gestire quale metodo usare


riprodurre classe fpcaData, usando la regression data


??? compute degrees of freedom stochastic cosa sono??

?? parte mumps come calcola??

	//! A method returning TRUE if the observations are located in the nodes of the mesh or FALSE otherwise
		inline bool isLocationsByNodes() const {return locations_by_nodes_;}


//_Verificare a cosa seve la stochastic per i degrees of freedom

NB se islocationbynodes è true, la matrice psi è identità


Da fare:
rendere scalare _dof e gcv 
e cercare metodo ottimale per calcolare le z_hat (o uso la H hat matrix e i valori di fn ecc oppure uso (I-Q+QS)*z


Nel codice R, lui calcola esternamentente la GCV, aspetta di avere il risultato completo in bogso, da cui estrae i deg of freedom, edf, usati poi nel resto, caclolando esplicitamente i  beta_hat, z-hat ecc nella get_GCV
Big sol usa la funzione c++ che scrive dentro i risultati




//_NB compute dof semplicemente dice se dovrà calcolare i dof o meno, se è true, ci mette il calcolo, che è tr(S)+q


//DA fare:
non serve più calcolare i dofs e esportarli nella bigsol, basta tenerli internamente (ottimizzazione), la gcv interna deve ricalcolare gli z_hat.
NOn servirà più nemmeno usare il vettore (lista) dei dofs, perchè la lambda sarà una sola
NB attenzione a capire come funziona il caclolo con MUMPS e i deg of freedom stochastic

possibile ripartizione del lavoro:
Io mi potrei occupare di caclolare GCV e sua derivata come funzioni, Giorgio potrebbe implementare il metodo di newton base 




ogttimizzazioni: meshobject.h funzione inutile che calcola phi e moltiplica per coeff, inutile
inversa di S con metodo MIDA o simili
storage dei valori di R1 ecc per averli già anche per la derivata
nel computedeoffreedom parte in cui usa Qe_i per trovare la colonna i-esima si potrebbbe evitare e usare Q[]

???controllare perchè la traccia è calcolata su num nodes e non num locations?? forse perchè nnodes>num locations e dove non c'è mette zero?


8 luglio
NB inputhandler e datahandler ora coincidono, messo wrapper per apply e aplly to b per evitare di avere puntatore pubblico
nel newton modificato controllo adattivo che se lambda è negativo riparte da un sottomultiplo del flesso+ controllo per capire se sono dentro o fuori-> rapporto incrementale in relativo e controllo se è maggiore o minore del 10%


interessante lasciare opzione verbose o no, in modo da dare più o meno info delle varie parti


Fondamentale : sistemato questione errore calcolo S da colli colombo LDLT-> usata partial piv LU per areale, con agggiunta genitale del metodo coi type traits per scegliere il tipo 


questione seed da sistemare


corretto il segno meno per la forzante, ora coincide tutto (già notato in ardenghi vicini)-> attenzione alla matrix no cov che in realtà nel secondo blocco ha i segni invertiti!!


metodo più efficace per trovare se la forma gcv è buona oppure no


NB aggiungere in output per newton il valore ottimo della GCV



NB far notare che nel batch si aus il .at per accedere, safer in caso ci fossero stati errori e il vettore non fosse stato costruito

ardenghi vicini

NB questione N_, al momento è nel cosntructor di mixed ferregression il numero di nodi

NB mettere sempre, per apply, template A alla fine, per far automatic template deduction

da completare set H, set Q e set DMat.

per il reposrt inizializzazione mostrare grafico gcv e i vari possibili valori di lambda iniziali. Eventuale dividere per 5 e non per 10 il vlaroe lambda scelto

lasciati const ref e non puntatore get solutions ecc, per cerenza col vecchio codice. ciò che serve al carriere è pointer



CONTROLLARE: mettere virtual la compute specific parameters? 
controllare output cosa restituisce il batch



modifiche a mixed: spezzato apply e preapply, costruite due versioni, temporale e non di buildsystem_matrix, resa più efficient DMat per evitare di ricostruire ogni volta. Membro interno lambda, per non avere apply che prende in ingresso lambda, più generale. Sintassia puntatore per salvare le decomposizioni di matrici

NB questione R defined

da sistemare: cfr con last lambda e question fpirls


NB SISTEMARE: far capire che nei cpp quelli che vengono da fdaPDE.cpp sono CORE, magari chiamarli con un nome comune... (30 luglio, a posteriori della divisione in cartelle)



Mettere che si è modificato caso di dof matrix se fornita dall'esterno


NB caso newton esatto da bloccare se si usano le BC (non implementato)

?? CHiedere caso areale come è implementato per le BC...va fatto???


NB CASO stocastico?? le bc vanno esse nella GCV????

NB per installazione windows, fare installare prima Rtools. Non presente in R 4.0
possibili problemi di compatibility con R 4.0




NB CASO stocastico?? le bc vanno esse nella GCV????

NB per installazione windows, fare installare prima Rtools. Non presente in R 4.0
possibili problemi di compatibility con R 4.0


NB dire nel newton che alla fine è meglio usare quello perchè le derivate andrebbero lo stesso calcolate



eventuale BC questione divisione per lambda
