 /*Real bisection(const Real &aa,const  Real &bb, const UInt& max_it, const Real &eval_a_, const Real &eval_b_)
 {    Real a=aa, b=bb;
      Real eval_a=eval_a_;
     if( eval_a*eval_b_>= 0)
     {
         Rprintf("\n Incorrect a and b\n");
         return 1;
     }


     Real c=a;
     UInt n_it=0;
     Real eval_c;

     while (n_it<max_it) //tell about interval is sufficently small
     {
         c = std::sqrt(a*b);

         eval_c=this->F.evaluate_second_derivative(c);
         if ( eval_c== 0.0){

             break;
         }
         else if (eval_c*eval_a < 0){

                 b=c;
         }
         else{

                 a=c;
                 eval_a=eval_c;
         }
         n_it++;

     }
   return c;
}*/


//Useless up to now
                /*Real bisection(const Real &aa,const  Real &bb, const UInt& max_it, const Real &eval_a_, const Real &eval_b_, const Real& h)
		{    Real a=aa, b=bb;
     		     Real eval_a=eval_a_;
    		if( eval_a*eval_b_>= 0)
                    {
                        Rprintf("\n Incorrect a and b\n");
                        return 1;
                    }


                    Real c=a;
                    UInt n_it=0;
                    Real eval_c;

                    while (n_it<max_it) //tell about interval is sufficently small
                    {
                        c = std::sqrt(a*b);

                        eval_c=this->second_derivative(c,h);
                        if ( eval_c== 0.0){

                            break;
                        }
                        else if (eval_c*eval_a < 0){

                                b=c;
                        }
                        else{

                                a=c;

               		        eval_a=eval_c;
                        }
                        n_it++;

                    }
                  return c;
                }


                Real second_derivative(const Real& x, const Real& h)
               {
                       Rprintf("Forward: \n");
                       Real fxph = this->F.evaluate_f(x+h);
                       Rprintf("Backward: \n");
                       Real fxmh = this->F.evaluate_f(x-h);
                       Rprintf("Center: \n");
                       Real fx  = this->F.evaluate_f(x);
                       return (fxph+fxmh-(2*fx))/(h*h);

                 }
                 
                 		        // Real a=1e-7;
			//Real b=0.5;
			
						/*
			Real eval_a=this->second_derivative(a,h); //useful to save one evaluation in the bisection method if the extrema are already correct
			Real eval_b=this->second_derivative(b,h);
                        while (eval_a<-0.0001)
                                  {a*=10;
				   eval_a=this->second_derivative(a,h);
                                   }
			while (eval_b>0.0001)
                                  {b*=10;
				   eval_b=this->second_derivative(b,h);}

                        Rprintf("\n Starting interval for preprocessing: [%f;%f]\n", a,b);

                        Real flesso=bisection(a,b,4, eval_a, eval_b,h);
 			Rprintf("\nFlesso at %f\n", flesso);

                      if (x>flesso/25 || x<a )
                              {x=flesso/50;
                                if (x<4e-6)
                                    x=5e-6;
				Rprintf("\nInitial value inserted is out of range, using default value lambda=%f\n",x);
				}

*/

