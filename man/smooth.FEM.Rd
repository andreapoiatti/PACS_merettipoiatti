% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/smoothing.R
\name{smooth.FEM}
\alias{smooth.FEM}
\title{Spatial regression with differential regularization}
\usage{
smooth.FEM(locations = NULL, observations, FEMbasis,
 covariates = NULL, PDE_parameters = NULL, BC = NULL,
 incidence_matrix = NULL, areal.data.avg = TRUE,
 search = "tree", bary.locations = NULL,
 family = "gaussian", mu0 = NULL, scale.param = NULL, threshold.FPIRLS = 0.0002020, max.steps.FPIRLS = 15,
 optimization = "batch", DOF_evaluation = "not_required", loss_function = "unused", lambda = NULL, nrealizations = 100, seed = 0, DOF_matrix = NULL, GCV.inflation.factor = 1, stop_criterion_tol = 0.05)
}
\arguments{
\item{locations}{A #observations-by-2 matrix in the 2D case and #observations-by-3 matrix in the 2.5D and 3D case, where
each row specifies the spatial coordinates \code{x} and \code{y} (and \code{z} in 2.5D and 3D) of the corresponding
observation in the vector \code{observations}.
If the locations of the observations coincide with (or are a subset of) the nodes of the mesh in the \code{FEMbasis},
leave the parameter \code{locations = NULL} for a faster implementation.}

\item{observations}{A vector of length #observations with the observed data values over the domain.
If the \code{locations} argument is left NULL the vector of the observations have to be of length #nodes of the
mesh in the FEMbasis. In this case, each observation is associated to the corresponding node in the mesh.
If the observations are observed only on a subset of the mesh nodes, fill with \code{NA} the values of the vector
\code{observations} in correspondence of unobserved data.}

\item{FEMbasis}{A \code{FEMbasis} object describing the Finite Element basis, as created by \code{\link{create.FEM.basis}}.}

\item{covariates}{A #observations-by-#covariates matrix where each row represents the covariates associated with
the corresponding observed data value in \code{observations} and each column is a different covariate.}

\item{PDE_parameters}{A list specifying the parameters of the PDE in the regularizing term. Default is NULL, i.e.
regularization is by means of the Laplacian (stationary, isotropic case).
If the coefficients of the PDE are constant over the domain \code{PDE_parameters} must contain:
\itemize{
   \item{\code{K}, a 2-by-2 matrix of diffusion coefficients. This induces an anisotropic
smoothing with a preferential direction that corresponds to the first eigenvector of the diffusion matrix K;}
   \item{\code{b}, a vector of length 2 of advection coefficients. This induces a
smoothing only in the direction specified by the vector \code{b};}
   \item{\code{c}, a scalar reaction coefficient. \code{c} induces a shrinkage of the surface to zero.}
}
If the coefficients of the PDE are space-varying \code{PDE_parameters} must contain:
\itemize{
\item{\code{K}, a function that for each spatial location in the spatial domain (indicated by the vector of the 2
spatial coordinates) returns a 2-by-2 matrix of diffusion coefficients. The function must support recycling for
efficiency reasons, thus if the input parameter is a #point-by-2 matrix, the output should be
an array with dimensions 2-by-2-by-#points.}
\item{\code{b}, a function that for each spatial location in the spatial domain returns
a vector of length 2 of transport coefficients. The function must support recycling for efficiency reasons, thus
if the input parameter is a #point-by-2 matrix, the output should be
a matrix with dimensions 2-by-#points;}
\item{\code{c}, a function that for each spatial location in the spatial domain  returns a scalar reaction coefficient.
The function must support recycling for efficiency reasons, thus if the input parameter is a #point-by-2 matrix, the output should be
a vector with length #points;}
\item{\code{u}, a function that for each spatial location in the spatial domain  returns a scalar reaction coefficient.
\code{u} induces a reaction effect. The function must support recycling for efficiency reasons, thus if the input
parameter is a #point-by-2 matrix, the output should be
a vector with length #points.}
}
For 2.5D and 3D, only the Laplacian is available (\code{PDE_parameters=NULL}).}

\item{BC}{A list with two vectors:
\code{BC_indices}, a vector with the indices in \code{nodes} of boundary nodes where a Dirichlet Boundary Condition should be applied;
\code{BC_values}, a vector with the values that the spatial field must take at the nodes indicated in \code{BC_indices}.}

\item{incidence_matrix}{A #regions-by-#triangles/tetrahedrons matrix where the element (i,j) equals 1 if the j-th
triangle/tetrahedron is in the i-th region and 0 otherwise.
This is needed only for areal data. In case of pointwise data, this parameter is set to \code{NULL}.}

\item{areal.data.avg}{Boolean. It involves the computation of Areal Data. If \code{TRUE} the areal data are averaged, otherwise not.}

\item{search}{a flag to decide the search algorithm type (tree or naive or walking search algorithm).}

\item{bary.locations}{A list with three vectors:
\code{locations}, location points which are same as the given locations options. (checks whether both locations are the same);
\code{element ids}, a vector of element id of the points from the mesh where they are located;
\code{barycenters}, a vector of barycenter of points from the located element.}

\item{family}{This parameter specify the distibution within exponential family used for GLM model.
The following distribution are implemented: "binomial", "exponential", "gamma", "poisson", "gaussian", "invgaussian".
The default link function for binomial is \code{logit} if you want either \code{probit} or \code{clogloc} set \code{family = "probit"}, \code{family = "cloglog"}.}

\item{mu0}{This parameter is a vector that set the starting point for FPIRLS algorithm. It represent an initial guess of the location parameter.
Default is set to observation for non binary distribution while equal to \code{0.5(observations + 0.5)} for binary data.}

\item{scale.param}{Dispersion parameter of the chosen distribution. This is only required for "gamma", "gaussian", "invgaussian".
User may specify the parameter as a positive real number. If the parameter is not supplied, it is estimated from data according to Wilhelm Sangalli 2016.}

\item{threshold.FPIRLS}{This parameter is used for arresting algorithm iterations. Algorithm stops when two successive iterations lead to improvement in penalized log-likelihood smaller than threshold.FPIRLS.
Default value \code{threshold.FPIRLS = 0.0002020}.}

\item{max.steps.FPIRLS}{This parameter is used to limit the maximum number of iteration.
Default value \code{max.steps.FPIRLS=15}.}

\item{optimization}{This parameter is used to select the optimization method related to the penalization factor.
The following methods are implemented: "batch", "newton", "newton_fd". 
The former is a pure evaluation method, therefore a vector of \code{lambda} testing penalizations must be provided.
The remaining two are optimization methods that automatically select the best penalization according to \code{loss_function} criterion.
They implement respectively a pure Newton method and a finite differences Newton method.
Default value \code{optimization="batch"}}

\item{DOF_evaluation}{This parameter is used to identify if and how degrees of freedom computation has to be performed
The following possibilities are allowed: "not_required", "exact" and "stochastic"
In the former case no degree of freedom is computed, while the other two methods enable computation.
Stochastic computation of dof may be slightly less accurate than its deterministic counterpart, but is higly suggested for meshes of more than 5000 nodes, being fairly less time consuming.
Default value \code{DOF_evaluation="not_required"}}

\item{loss_function}{This parameter is used to understand if some loss function has to be evaluated.
The following possibilities are allowed: "unused" and "GCV" (generalized cross validation)
In the former case is that of \code{optimization='batch'} pure evaluation, while the second can be employed for optimization methods.
Default value \code{loss_function="unused"}}

\item{lambda}{a vector of penalization factors to be provided for evaluation if \code{optimization="batch"}, an optional initialization otherwise}

\item{nrealizations}{This parameter is considered only when \code{DOF_evaluation = 'stochastic'}.
It is a positive integer that represents the number of uniform random variables used in stochastic GCV computation.
Default value \code{nrealizations=100}.}

\item{seed}{This parameter is considered only when \code{DOF_evaluation = 'stochastic'}.
It is a positive integer that represents user defined seed employed in stochastic GCV computation.
Default value \code{seed=0}.}

\item{DOF_matrix}{Matrix of degrees of freedom. This parameter can be used if the DOF_matrix corresponding to \code{lambda} is available from precedent computation. This allows to save time
since the computation of the dof is the most expensive part of GCV.}

\item{GCV.inflation.factor}{Tuning parameter used for the estimation of GCV. Default value \code{GCV.inflation.factor = 1.8}.
It is advised to set it grather than 1 to avoid overfitting.}

\item{stop_criterion_tol}{Tolerance parameter, a double between 0 and 1 that fixes how much precision is required by the optimization method: the smaller the parameter, the higher the accuracy.
Used only if \code{optimization="newton"} or \code{optimization="newton_fd"}.
Default value \code{stop_criteion_tol=0.05}.}
}
\description{
This function implements a spatial regression model with differential regularization.
 The regularizing term involves a Partial Differential Equation (PDE). In the simplest case the PDE involves only the
 Laplacian of the spatial field, that induces an isotropic smoothing. When prior information about the anisotropy or
 non-stationarity is available the PDE involves a general second order linear differential operator with possibly
 space-varying coefficients.
 The technique accurately handle data distributed over irregularly shaped domains. Moreover, various conditions
 can be imposed at the domain boundaries.
}
\examples{
library(fdaPDE)

#### No prior information about anysotropy/non-stationarity (laplacian smoothing) ####
data(horseshoe2D)
boundary_nodes = horseshoe2D$boundary_nodes
boundary_segments = horseshoe2D$boundary_segments
locations = horseshoe2D$locations

mesh = create.mesh.2D(nodes = rbind(boundary_nodes, locations), segments = boundary_segments)
FEMbasis = create.FEM.basis(mesh)
lambda = 10^-1
# no covariate
data = fs.test(mesh$nodes[,1], mesh$nodes[,2]) + rnorm(nrow(mesh$nodes), sd = 0.5)

solution = smooth.FEM(observations = data, FEMbasis = FEMbasis, lambda = lambda)
plot(solution$fit.FEM)

# with covariates
covariate = covs.test(mesh$nodes[,1], mesh$nodes[,2])
data = fs.test(mesh$nodes[,1], mesh$nodes[,2]) + 2*covariate + rnorm(nrow(mesh$nodes), sd = 0.5)

solution = smooth.FEM(observations = data, covariates = covariate, FEMbasis = FEMbasis, lambda = lambda)

# beta estimate:
solution$solution$beta
# non-parametric estimate:
plot(solution$fit.FEM)

# Choose lambda with GCV:
lambda = 10^(-2:2)
solution = smooth.FEM(observations = data,
                            covariates = covariate,
                            FEMbasis = FEMbasis,
                            lambda = lambda, DOF_evaluation = 'stochastic', loss_function = 'GCV')
bestLambda = solution$optimization$lambda_solution


#### Smoothing with prior information about anysotropy/non-stationarity and boundary conditions ####
# See Azzimonti et al. for reference to the current exemple
data(quasicircle2D)
boundary_nodes = quasicircle2D$boundary_nodes
boundary_segments = quasicircle2D$boundary_segments
locations = quasicircle2D$locations
data = quasicircle2D$data

mesh = create.mesh.2D(nodes = rbind(boundary_nodes, locations), segments = boundary_segments)
FEMbasis = create.FEM.basis(mesh)
lambda = 10^-2

# Set the PDE parameters
R = 2.8
K1 = 0.1
K2 = 0.2
beta = 0.5
K_func<-function(points)
{
  output = array(0, c(2, 2, nrow(points)))
  for (i in 1:nrow(points))
    output[,,i]=10*rbind(c(points[i,2]^2+K1*points[i,1]^2+K2*(R^2-points[i,1]^2-points[i,2]^2),
                           (K1-1)*points[i,1]*points[i,2]),
                         c((K1-1)*points[i,1]*points[i,2],
                           points[i,1]^2+K1*points[i,2]^2+K2*(R^2-points[i,1]^2-points[i,2]^2)))
  output
}

b_func<-function(points)
{
  output = array(0, c(2, nrow(points)))
  for (i in 1:nrow(points))
    output[,i] = 10*beta*c(points[i,1],points[i,2])
  output
}

c_func<-function(points)
{
  rep(c(0), nrow(points))
}

u_func<-function(points)
{
  rep(c(0), nrow(points))
}
PDE_parameters = list(K = K_func, b = b_func, c = c_func, u = u_func)

# Set the boundary conditions
BC = NULL
BC$BC_indices = which(mesh$nodesmarkers == 1) # b.c. on the complete boundary
BC$BC_values = rep(0,length(BC$BC_indices)) # homogeneus b.c.

# Since the data locations are a subset of the mesh nodes for a faster solution use:
dataNA = rep(NA, FEMbasis$nbasis)
dataNA[mesh$nodesmarkers == 0] = data

solution = smooth.FEM(observations = dataNA,
                            FEMbasis = FEMbasis,
                            lambda = lambda,
                            PDE_parameters = PDE_parameters,
                            BC = BC)
plot(solution$fit.FEM)
image(solution$fit.FEM)

#### Smoothing with areal data ####
# See Azzimonti et al. for reference to the current exemple
data(quasicircle2Dareal)
incidence_matrix = quasicircle2Dareal$incidence_matrix
data = quasicircle2Dareal$data
mesh = quasicircle2Dareal$mesh

FEMbasis = create.FEM.basis(mesh)
lambda = 10^-4

# Set the PDE parameters
R = 2.8
K1 = 0.1
K2 = 0.2
beta = 0.5
K_func<-function(points)
{
  output = array(0, c(2, 2, nrow(points)))
  for (i in 1:nrow(points))
    output[,,i]=10*rbind(c(points[i,2]^2+K1*points[i,1]^2+K2*(R^2-points[i,1]^2-points[i,2]^2),
                           (K1-1)*points[i,1]*points[i,2]),
                         c((K1-1)*points[i,1]*points[i,2],
                           points[i,1]^2+K1*points[i,2]^2+K2*(R^2-points[i,1]^2-points[i,2]^2)))
  output
}

b_func<-function(points)
{
  output = array(0, c(2, nrow(points)))
  for (i in 1:nrow(points))
    output[,i] = 10*beta*c(points[i,1],points[i,2])
  output
}

c_func<-function(points)
{
  rep(c(0), nrow(points))
}

u_func<-function(points)
{
  rep(c(0), nrow(points))
}
PDE_parameters = list(K = K_func, b = b_func, c = c_func, u = u_func)

# Set the boundary conditions
BC = NULL
BC$BC_indices = which(mesh$nodesmarkers == 1) # b.c. on the complete boundary
BC$BC_values = rep(0,length(BC$BC_indices)) # homogeneus b.c.

solution = smooth.FEM(observations = data,
                            incidence_matrix = incidence_matrix,
                            FEMbasis = FEMbasis,
                            lambda = lambda,
                            PDE_parameters = PDE_parameters,
                            BC = BC)
plot(solution$fit.FEM)
image(solution$fit.FEM)

}
\references{
\itemize{
   \item{Sangalli, L. M., Ramsay, J. O., Ramsay, T. O. (2013). Spatial spline regression models.
Journal of the Royal Statistical Society: Series B (Statistical Methodology), 75(4), 681-703.}
   \item{Azzimonti, L., Sangalli, L. M., Secchi, P., Domanin, M., Nobile, F. (2015). Blood flow velocity field estimation
via spatial regression with PDE penalization. Journal of the American Statistical Association, 110(511), 1057-1071.}
   \item{Matthieu Wilhelm & Laura M. Sangalli (2016). Generalized spatial regression with differential regularization.
 Journal of Statistical Computation and Simulation, 86:13, 2497-2518.}
}
}
