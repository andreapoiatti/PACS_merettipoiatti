#' Plot a \code{FEM} object
#' 
#' @param x A \code{FEM} object.
#' @param num_refinements A natural number specifying how many bisections should be applied to each triangular element for
#' plotting purposes. This functionality is useful where a discretization with 2nd order Finite Element is applied. This parameter can be specified only when a planar mesh (\code{MESH2D}) object is plotted.
#' @param ... Arguments representing graphical options to be passed to \link[rgl]{plot3d}.
#' @description Three-dimensional plot of a \code{FEM} object, generated by \code{FEM} or returned by \code{smooth.FEM.basis}, \code{smooth.FEM.PDE.basis},
#' \code{smooth.FEM.PDE.sv.basis} or \code{smooth.FEM.FPCA}. 
#'If the \code{mesh} of the \code{FEMbasis} component is of class \code{MESH2D} both the 3rd axis and the color represent the value of the coefficients for the Finite Element basis expansion (\code{coeff} component of the \code{FEM} object). If the \code{mesh} is of class \code{MESH.2.5D} or \code{MESH.3D}, the color of each triangle or tetrahedron represent the mean value of the coefficients for the Finite Element basis expansion(\code{coeff}).
#' @usage \method{plot}{FEM}(x, num_refinements, ...)  
#' @seealso \code{\link{image.FEM}}, \code{\link{FEM}}
#' @examples 
#' ## Upload a triangular mesh and plot it
#' data("mesh.2D.rectangular")
#' plot(mesh.2D.rectangular)
#' ## Create a linear Finite Element basis
#' FEMbasis = create.FEM.basis(mesh.2D.rectangular)
#' ## Define a sinusoidal function as expansion of this basis and plot it
#' coeff <- sin(mesh.2D.rectangular$nodes[,1])*cos(mesh.2D.rectangular$nodes[,2])
#' FEM_object<- FEM(coeff, FEMbasis)
#' plot(FEM_object)

plot.FEM = function(x, num_refinements = NULL, ...)  
{
if(class(x$FEMbasis$mesh)=="MESH2D"){
  if(x$FEMbasis$order == 1)
  {
    R_plot.ORD1.FEM(x, ...)
  }else{
    R_plot.ORDN.FEM(x, num_refinements, ...)
  }
}else if(class(x$FEMbasis$mesh)=="MESH.2.5D"){
	R_plot_manifold(x,...)
}else if(class(x$FEMbasis$mesh)=="MESH.3D"){
	R_plot_volume(x,...)
}
}

#' Image Plot of a FEM
#' 
#' @param x A \code{FEM} object.
#' @param num_refinements A natural number specifying how many bisections should by applied to each triangular element for
#' plotting purposes. This functionality is useful where a discretization with 2nd order Finite Element is applied.
#' @param ... Arguments representing  graphical options to be passed to \link[rgl]{plot3d}.
#' @description Image plot of a \code{FEM} object, generated by the function \code{FEM} or returned by \code{smooth.FEM.basis}, \code{smooth.FEM.PDE.basis} or
#' \code{smooth.FEM.PDE.sv.basis} can be visualized through an image plot. Only planar mesh (\code{MESH2D}) objects can be plotted with this method.
#' @usage \method{image}{FEM}(x, num_refinements, ...)  
#' @seealso \code{\link{plot.FEM}}
#' @examples 
#' ## Upload a triangular mesh and plot it
#' data("mesh.2D.rectangular")
#' plot(mesh.2D.rectangular)
#' ## Create a linear Finite Element basis
#' FEMbasis = create.FEM.basis(mesh.2D.rectangular)
#' ## Define a sinusoidal function as expansion of this basis and plot it
#' coeff <- sin(mesh.2D.rectangular$nodes[,1])*cos(mesh.2D.rectangular$nodes[,2])
#' FEM_object<- FEM(coeff, FEMbasis)
#' image(FEM_object)
image.FEM = function(x, num_refinements = NULL, ...)  
{
  if(x$FEMbasis$order == 1)
  {
    R_image.ORD1.FEM(x, ...)
  }else{
    R_image.ORDN.FEM(x, num_refinements, ...)
  }
}


#' Plot a MESH2D object
#' 
#' @param x A MESH2D object defining the triangular mesh, as generated by \code{create.Mesh.2D} or \code{refine.Mesh.2D}.
#' @param ... Arguments representing graphical options to be passed to \link[graphics]{par}.
#' @description Plot a mesh MESH2D object, generated by \code{create.MESH.2D} or \code{refine.MESH.2D}. Circles indicate the mesh nodes.
#' @usage \method{plot}{MESH2D}(x, ...)
#' @examples 
#' ## Upload the Meuse data and a domain boundary
#' data(MeuseData)
#' data(MeuseBorder)
#' ## Create a triangular mesh with the provided boundary
#' mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = 1)
#' ## Plot it
#' plot(mesh)
plot.MESH2D<-function(x, ...)
{
  plot(x$nodes, xlab="", ylab="", xaxt="n", yaxt="n", bty="n", ...)
  segments(x$nodes[x$edges[,1],1], x$nodes[x$edges[,1],2],
           x$nodes[x$edges[,2],1], x$nodes[x$edges[,2],2], ...)
  segments(x$nodes[x$segments[,1],1], x$nodes[x$segments[,1],2],
           x$nodes[x$segments[,2],1], x$nodes[x$segments[,2],2], col="red", ...)
}
#' Plot a MESH.2.5D object
#'
#' @param mesh A \code{MESH.2.5D} object generated by \code{create.MESH.2.5D} or \code{second.order.MESH.2.5D}.
#' @param ... Arguments representing graphical options to be passed to \link[graphics]{par}.
#' @description Plot the triangulation of a mesh \code{MESH.2.5D} object, generated by \code{create.MESH.2.5D} or \code{second.order.MESH.2.5D}. The points indicates the mesh nodes.
#' @examples
#' ##Load a MESH.2.5D object
#' data(candy)
#' ##Plot the triangulation of the object
#' plot.MESH.2.5D(candy)


plot.MESH.2.5D<-function(mesh,...){

  if(!require(rgl)){
    stop("The plot MESH.2.5D_function(...) requires the R package rgl, please install it and try again!")
  }
  
  triangles = mesh$triangles
  ntriangles=mesh$ntriangles
  
  order=mesh$order
  
  nodes=matrix(mesh$nodes,nrow=mesh$nnodes,ncol=3,byrow=TRUE)
  
  edges=matrix(rep(0,6*ntriangles),ncol=2)
  for(i in 0:(ntriangles-1)){
  edges[3*i+1,]=c(triangles[3*order*i+1],triangles[3*order*i+2])
  edges[3*i+2,]=c(triangles[3*order*i+1],triangles[3*order*i+3])
  edges[3*i+3,]=c(triangles[3*order*i+2],triangles[3*order*i+3])
  }
  edges=edges[!duplicated(edges),]
  edges<-as.vector(t(edges))
  open3d()
  axes3d()
  rgl.pop("lights") 
  light3d(specular="black") 
  
  rgl.points(x = nodes[ ,1], y = nodes[ ,2], 
                  z=nodes[,3],col="black", ...)
                  
  rgl.lines(x = nodes[edges ,1], y = nodes[edges ,2], 
                  z=nodes[edges,3],col="black",...)
    
  aspect3d("iso")
  rgl.viewpoint(0,-45)

}


#' Plot a MESH.3D object
#'
#' @param mesh A \code{MESH.3D} object generated by \code{create.MESH.3D} or \code{second.order.MESH.3D}.
#' @param ... Arguments representing graphical options to be passed to \link[graphics]{par}.
#' @description Plot the triangulation of a mesh \code{MESH.3D} object, generated by \code{create.MESH.3D}. The points indicates the mesh nodes.
#' @examples
#' ##Load a MESH.3D object
#' data(sphere3D)
#' ##Plot the triangulation of the object
#' plot.MESH.3D(sphere3D)


plot.MESH.3D<-function(mesh,...){

  if(!require(rgl)){
    stop("The plot MESH.2.5D_function(...) requires the R package rgl, please install it and try again!")
  }
  #if(!require(geometry)){
   # stop("The plot MESH.3D_function(...) requires the R package geometry, please install it and try again!")
 # }
  
  tetrahedrons = matrix(mesh$tetrahedrons,nrow=mesh$ntetrahedrons,ncol=4,byrow=TRUE)
  ntetrahedrons=mesh$ntetrahedrons
  
  nodes=matrix(mesh$nodes,nrow=mesh$nnodes,ncol=3,byrow=TRUE)
 
  tet=t(rbind(tetrahedrons[,-1],tetrahedrons[,-2],tetrahedrons[,-3],tetrahedrons[,-4]))
  
  open3d()
  axes3d()
  rgl.pop("lights") 
  light3d(specular="black") 
  
  rgl.triangles(nodes[tet,1],nodes[tet,2],nodes[tet,3],col="white",...)
    
  aspect3d("iso")
  rgl.viewpoint(0,-45)

}

#' Isosurface Plot of a FEMevaluated object
#' 
#' @param FEMevaluated A \code{FEMevaluated} object.
#' @param levels The levels at which the isosurfaces are generated. If levels is a vector, isosurfaces are generated for each level. The value of the levels has to be in the range of the possible \code{evaluated_values} of the \code{FEMevaluated} object.
#' @param ... Arguments representing  graphical options to be passed to \link[rgl]{plot3d}.
#' @description Isosurface plot of a \code{FEMevaluated} object, generated by the function \code{evaluate.grid.FEM}. This method is useful for plotting volumetric mesh (\code{MESH.3D}) objects.
#' @usage isosurfaces.FEMevaluated(FEMevaluated,levels,...)  
#' @seealso \code{\link{evaluate.grid.FEM}}
#' @examples 
#' ## Upload a tetrahedral mesh and plot it
#' data(sphere3D)
#' plot(sphere3D)
#' ##Define the number of nodes
#' nnodes=sphere3D$nnodes
#' ## Create a linear Finite Element basis
#' FEMbasis = create.FEM.basis(sphere3D)
#' ## Define a function as expansion of this basis
#' coeff=numeric(nnodes)
#' for(i in 0:nnodes-1){
#' 	coeff[i+1] <- 0.5*sqrt(15/pi)*sphere3D$nodes[3*i+1]*sphere3D$nodes[3*i+2]
#' }
#' FEM_object<- FEM(coeff, FEMbasis)
#' ##Create the grid of evaluated points
#' FEMevaluated=evaluate.grid.FEM(FEM_object)
#' ##Plot the isosurfaces
#' isosurfaces.FEMevaluated(FEMevaluated,levels=seq(-0.45,0.45,by=0.15))
isosurfaces.FEMevaluated<-function(FEMevaluated,levels,...)
{
  if(!require(plot3Drgl)){
    stop("The isosurfaces.FEMevaluated_function(...) requires the R package plot3Drgl,   please install it and try again!")
  }
  if (is.null(FEMevaluated)) 
    stop("FEMevaluated required;  is NULL.")
  if(class(FEMevaluated) != "FEMevaluated")
    stop("'FEMevaluated' is not of class 'FEMevaluated'")
    if (is.null(levels)) 
    stop("levels required;  is NULL.")
  
  ndata=length(FEMevaluated$evaluated_values)
  
  for(idata in 1:ndata)
  {
   	isosurf3Drgl(x=FEMevaluated$x,y=FEMevaluated$y,z=FEMevaluated$z,colvar=FEMevaluated$evaluated_values[[idata]],level=levels,col=jet.col(length(levels),alpha=0.7), ...)
   	axes3d()
	rgl.pop("lights") 
  	light3d(specular="black")
  	aspect3d("iso")
  	rgl.viewpoint(0,-45)
  	
  	if (ndata > 1 && idata<ndata)
    	{readline("Press a button for the next plot...")}
    }
 } 


#' Slice Plot of a FEMevaluated object
#' 
#' @param FEMevaluated A \code{FEMevaluated} object.
#' @param xs Vector specifying the position in x where the slices(planes) has to be drawn. The values of \code{evaluated_values} of the \code{FEMevaluated} object are projected on these slices.
#' @param ys Vector specifying the position in y where the slices(planes) has to be drawn. The values of \code{evaluated_values} of the \code{FEMevaluated} object are projected on these slices.
#' @param zs Vector specifying the position in z where the slices(planes) has to be drawn. The values of \code{evaluated_values} of the \code{FEMevaluated} object are projected on these slices.
#' @param ... Arguments representing  graphical options to be passed to \link[rgl]{plot3d}.
#' @description Slice plot of a \code{FEMevaluated} object, generated by the function \code{evaluate.grid.FEM}. This method is useful for plotting volumetric mesh (\code{MESH.3D}) objects.
#' @usage slices.FEMevaluated(FEMevaluated,xs=0,ys=NULL,zs=NULL,...)  
#' @seealso \code{\link{evaluate.grid.FEM}}
#' @examples 
#' ## Upload a tetrahedral mesh and plot it
#' data(sphere3D)
#' plot(sphere3D)
#' ##Define the number of nodes
#' nnodes=sphere3D$nnodes
#' ## Create a linear Finite Element basis
#' FEMbasis = create.FEM.basis(sphere3D)
#' ## Define a function as expansion of this basis
#' coeff=numeric(nnodes)
#' for(i in 0:nnodes-1){
#' 	coeff[i+1] <- 0.5*sqrt(15/pi)*sphere3D$nodes[3*i+1]*sphere3D$nodes[3*i+2]
#' }
#' FEM_object<- FEM(coeff, FEMbasis)
#' ##Create the grid of evaluated points
#' FEMevaluated=evaluate.grid.FEM(FEM_object)
#' ##Plot the slices
#' slices.FEMevaluated(FEMevaluated,xs=c(-0.5,0,0.5),ys=c(-0.5,0,0.5),NAcol="transparent")

slices.FEMevaluated<-function(FEMevaluated,xs=0,ys=NULL,zs=NULL,...)
{
  if(!require(plot3Drgl)){
    stop("The isosurfaces.FEMevaluated_function(...) requires the R package plot3Drgl,   please install it and try again!")
  }
  if (is.null(FEMevaluated)) 
    stop("FEMevaluated required;  is NULL.")
  if(class(FEMevaluated) != "FEMevaluated")
    stop("'FEMevaluated' is not of class 'FEMevaluated'")
  
  ndata=length(FEMevaluated$evaluated_values)
  
  for(idata in 1:ndata)
  {
   	slice3Drgl(x=FEMevaluated$x,y=FEMevaluated$y,z=FEMevaluated$z,colvar=FEMevaluated$evaluated_values[[idata]],xs=xs,ys=ys,zs=zs, ...)
   	axes3d()
	rgl.pop("lights") 
  	light3d(specular="black")
  	aspect3d("iso")
  	rgl.viewpoint(0,-45)
  	
  	if (ndata > 1 && idata<ndata)
    	{readline("Press a button for the next plot...")}
    }
 } 
 
 
 #' Slice Contour Plot of a FEMevaluated object
#' 
#' @param FEMevaluated A \code{FEMevaluated} object.
#' @param xs Vector specifying the position in x where the slices(planes) has to be drawn. The values of \code{evaluated_values} of the \code{FEMevaluated} object are projected on these slices as contours.
#' @param ys Vector specifying the position in y where the slices(planes) has to be drawn. The values of \code{evaluated_values} of the \code{FEMevaluated} object are projected on these slices as contours.
#' @param zs Vector specifying the position in z where the slices(planes) has to be drawn. The values of \code{evaluated_values} of the \code{FEMevaluated} object are projected on these slices as contours.
#' @param ... Arguments representing  graphical options to be passed to \link[rgl]{plot3d}.
#' @description Slice contour plot of a \code{FEMevaluated} object, generated by the function \code{evaluate.grid.FEM}. This method is useful for plotting volumetric mesh (\code{MESH.3D}) objects.
#' @usage slicecontours.FEMevaluated(FEMevaluated,xs=0,ys=NULL,zs=NULL,...)  
#' @seealso \code{\link{evaluate.grid.FEM}}
#' @examples 
#' ## Upload a tetrahedral mesh and plot it
#' data(sphere3D)
#' plot(sphere3D)
#' ##Define the number of nodes
#' nnodes=sphere3D$nnodes
#' ## Create a linear Finite Element basis
#' FEMbasis = create.FEM.basis(sphere3D)
#' ## Define a function as expansion of this basis
#' coeff=numeric(nnodes)
#' for(i in 0:nnodes-1){
#' 	coeff[i+1] <- 0.5*sqrt(15/pi)*sphere3D$nodes[3*i+1]*sphere3D$nodes[3*i+2]
#' }
#' FEM_object<- FEM(coeff, FEMbasis)
#' ##Create the grid of evaluated points
#' FEMevaluated=evaluate.grid.FEM(FEM_object)
#' ##Plot the contour on the slices
#' slicecontours.FEMevaluated(FEMevaluated,xs=c(-0.5,0,0.5),ys=0,NAcol="blue")
 slicecontours.FEMevaluated<-function(FEMevaluated,xs=0,ys=NULL,zs=NULL,...)
{
  if(!require(plot3Drgl)){
    stop("The isosurfaces.FEMevaluated_function(...) requires the R package plot3Drgl,   please install it and try again!")
  }
  if (is.null(FEMevaluated)) 
    stop("FEMevaluated required;  is NULL.")
  if(class(FEMevaluated) != "FEMevaluated")
    stop("'FEMevaluated' is not of class 'FEMevaluated'")
  
  ndata=length(FEMevaluated$evaluated_values)
  
  for(idata in 1:ndata)
  {
   	slicecont3Drgl(x=FEMevaluated$x,y=FEMevaluated$y,z=FEMevaluated$z,colvar=FEMevaluated$evaluated_values[[idata]],xs=xs,ys=ys,zs=zs,border="white", ...)
   	axes3d()
	rgl.pop("lights") 
  	light3d(specular="black")
  	aspect3d("iso")
  	rgl.viewpoint(0,-45)
  	
  	if (ndata > 1 && idata<ndata)
    	{readline("Press a button for the next plot...")}
    }
 } 
